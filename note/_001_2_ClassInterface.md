## Kotlin 类2 - 抽象类与接口

---


### 1. Kotlin 类、抽象类、接口的规则：
1. 「单继承多现实」即一个类只可以继承一个父类，但可以实现多个接口；
2. 「继承实现后使用」抽象类和接口不能直接创建对象，都需要被子类继承实现后，用子类进行创建；
3. 父类（接口）变量可以接受子类（实现类）的实例赋值；

### 2. 接口

+ Kotlin 中，接口具有以下特征：
> 1. 接口中可以定义属性，但是不能初始化，也不能有 getter/setter 方法，但是在它的实现类中必须被实现；
> 2. 可以给接口函数创建默认实现（在它的实现类中可以不必实现该函数）；
> 3. 对于抽象函数，必须在它的实现类中给出该函数的实现；

```
interface A {

    /* 1. 接口中可以定义属性，但是不能初始化，也不能有 getter/setter 方法，但是在它的实现类中必须被实现；
     */
    var a: Int

    /* 2. 可以给接口函数创建默认实现（在它的实现类中可以不必实现该函数）；
     */
    fun printA() {
        println("a --> $a")
    }

    /* 3. 对于抽象函数，必须在它的实现类中给出该函数的实现；
     */
    fun printA1()
}

/* A1. 接口A 的实现类必须实现其父接口已经定义过的 属性a；
 */
class implA(override var a: Int) : A {

    /* A3. 接口A 的实现类必须实现其父接口的 抽象函数printA1()；
     */
    override fun printA1() {
    }
}
```

### 3. 抽象类

+ Kotlin 中，抽象类具有以下特征：
> 1. 可以定义属性，同时属性也可以赋初始值；
> 2. 可以创建函数以及函数体，也可以输出类所对应的属性；
> 3. 与接口一样，对于抽象的函数，必须在其实现类中给出该函数的实现；

```
abstract class B {

    /* 1. 可以定义属性，同时属性也可以赋初始值；
     */
    var b = 10

    /* 2. 可以创建函数以及函数体，也可以输出类所对应的属性；
     */
    fun printB() {
        println(b)
    }

    /* 3. 与接口一样，对于抽象的函数，必须在其实现类中给出该函数的实现；
     */
    abstract fun printB1()
}

class implB : B() {

    /* B3. 抽象类B 的实现类必须实现其父类的 抽象函数printB1()；
     */
    override fun printB1() {
    }

}
```